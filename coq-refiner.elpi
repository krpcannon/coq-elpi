/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate coq-lib.

macro @stack :- list term.

type  nth-ctx int -> @stack -> @stack -> A -> @stack -> prop.
mode (nth-ctx i i o o o).
nth-ctx 0 [X|XS] [] X XS.
nth-ctx N [X|XS] [X|Before] At After :-
  M is N - 1, nth-ctx M XS Before At After.

%%%%% whd in out %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

mode (match-red i i i i o o).
match-red GR KArgs BL C X XC :-
  coq-env-indc GR Lno Ki _,
  drop Lno KArgs Args,
  nth Ki BL Bi,
  hd-beta {mk-app Bi Args} C X XC.

mode (fix-red i i i i i i o o). 
fix-red F Fix LA GR KA RA X XC :-
  ArgsWRedRecNo := append LA [{mk-app (indc GR) KA}|RA],
  hd-beta {mk-app (F Fix) ArgsWRedRecNo} [] X XC.

type val term -> term -> term -> prop.

macro @stack :- list term.
mode (whd i i o o).
type whd term -> @stack -> term -> @stack -> prop.
% FIXME does not keep the reduced, see whd-indc
% whd A B C D :- $print (whd A B C D), fail.

whd (app [Hd|Args]) C X XC :- !, whd Hd {append Args C} X XC.
whd (lam _ _ _ as X) [] X [] :- !.
whd (lam N T F) [A|AS] X XC :- !, whd (let N T A F) AS X XC.
% whd (lam N T F) [A|AS] X XC :- !, whd (F A) AS X XC.
whd (let _  _ B F) C X XC :- !,
  (pi x\ val x B _BN => whd (F x) C (F1 x) (C1 x)), X = F1 B, XC = C1 B.
% whd (let _  _ B F) C X XC :- !, whd (F B) C X XC.
whd (const GR) C X XC :- unfold GR C D DC, !, whd D DC X XC.
whd (match A _ L) C X XC :- whd-indc A GR KA, !,
  whd {match-red GR KA L C} X XC.
whd (fix _ Rno _ F as Fix) C X XC :- nth-ctx Rno C LA A RA, whd-indc A GR KA, !,
  whd {fix-red F Fix LA GR KA RA} X XC.
whd N C X XC :- $is_name N, val N V VN, !, cache-whd VN V, whd VN C X XC.
whd X C X C.

% strong T C X XC :-
%   whd T C X C1, map (x\y\sigma w wc\ strong x [] w wc, zip w wc y) C1 XC.

mode (cache-whd i i).
cache-whd (?? as K) V :- !, whd V [] X XC, zip X XC K.
cache-whd _ _.

mode (zip i i o).
zip T A R :- mk-app T A R.

mode (hd-beta i i o o).
hd-beta (app [Hd|Args]) S X C :- !, hd-beta Hd {append Args S} X C.
% hd-beta (lam N T F) [A|AS] X C :- !, hd-beta (let N T A F) AS X C.
hd-beta (lam _ _ F) [A|AS] X C :- !, hd-beta (F A) AS X C.
hd-beta (?? as K) A X [] :- !, mk-app K A X.
hd-beta X C X C.

mode (hd-beta-zeta i i o o).
hd-beta-zeta (app [Hd|Args]) S X C :- !, hd-beta-zeta Hd {append Args S} X C.
hd-beta-zeta (lam N T F) [A|AS] X C :- !, hd-beta-zeta (F A) AS X C.
hd-beta-zeta (let N T B F) AS X C :- !, hd-beta-zeta (F B) AS X C.
hd-beta-zeta (?? as K) A X [] :- !, mk-app K A X.
hd-beta-zeta X C X C.

hd-beta-zeta-reduce T R :- hd-beta-zeta T [] H S, zip H S R.

unfold GR A BO BOC :- coq-env-const GR B _, hd-beta B A BO BOC.

whd-indc A GR KA :- whd A [] VA C, !, VA = indc GR, KA = C.

% invariant: hd-beta terms
% we start with ff, tt to handle symmetric cases
% NOTE: rec-calls with unify (ensured hd-beta + ff) , symmetric rules are typically !
% NOTE: asymmetric rules are not ! otherwise the flip rule is killed
% NOTE: whd are !
type unif term -> @stack -> term -> @stack -> bool -> prop.
mode (unif i i i i i).
%@(log unif _ _ _ _ _).

% flexible cases
unif (?? as K) [] T B _ :- $llam_unif K {zip T B}, !.
unif T B (?? as K) [] _ :- $llam_unif K {zip T B}, !.
unif (?? V L) [] T B _ :- bind-list L {zip T B} V, !.
unif T B (?? V L) [] _ :- bind-list L {zip T B} V, !.

unif (sort S1) [] (sort S2) [] _ :- !, ignore-failure(S1 = S2).  % FIXME
unif (indt GR) B1 (indt GR) B2 _ :- !, unify-ctxs B1 B2.
unif (indc GR) B1 (indc GR) B2 _ :- !, unify-ctxs B1 B2.
unif X B1 (indt _ as T2) B2 ff :- !, unif T2 B2 {whd X B1} tt.
unif X B1 (indc _ as T2) B2 ff :- !, unif T2 B2 {whd X B1} tt.

% whd-iota? a bit aggressive
unif (match A _ L) B1 T B2 M :- whd-indc A GR KA, !,
  unif {match-red GR KA L B1} T B2 M.
unif (fix _ Rno _ F as Fix) B1 T B2 M :- nth-ctx Rno B1 LA A RA, whd-indc A GR KA, !,
  unif {fix-red F Fix LA GR KA RA} T B2 M.

% ctx (stuck terms)
unif (lam N T1 F1) [] (lam M T2 F2) [] _ :- !, ignore-failure(N = M), unify T1 T2,
  pi x\ (pp x N :- !) => (of x T1 x) => unify (F1 x) (F2 x). % of needed ?
unif (prod N T1 F1) [] (prod M T2 F2) [] _ :- !, ignore-failure(N = M), unify T1 T2,
  pi x\ (pp x N :- !) => (of x T1 x) => unify (F1 x) (F2 x). % of needed ?
unif (match A1 R1 L1) B1 (match A2 R2 L2) B2 _ :- !,
  unify A1 A2, unify R1 R2, unify-list L1 L2, unify-ctxs B1 B2.
unif (fix N Rno Ty1 F1) B1 (fix M Rno Ty2 F2) B2 _ :- !, ignore-failure(N = M),
  unify Ty1 Ty2, (pi f\ unify (F1 f) (F2 f)), unify-ctxs B1 B2.

% delta stuff
unif (const C) B1 (const C) B2 _ :- unify-ctxs B1 B2, !.
unif (const C) B1 T2 B2 M :- unfold C B1 T1' B1', !, unif T1' B1' T2 B2 M.

unif (let N T1 B1 F1) C1 (let M T2 B2 F2) C2 _ :-
  unify T1 T2, unify B1 B2, ignore-failure(N = M),
  (pi x\ @pp x N => val x B1 _ => unify (F1 x) (F2 x)),
  unify-ctxs C1 C2.
 
% unif (let _ _ B F) C1 T C2 M :- !, $print "L", unif {hd-beta (F B) C1} T C2 M.
unif (let N _ B F) C1 T C2 M :- !,
  pi x\ @pp x N => val x B _BN => unif {hd-beta (F x) C1} T C2 M.

% heigen variables
unif X C1 Y C2 _ :- $is_name X, $is_name Y, X = Y, unify-ctxs C1 C2.

unif X C1 T C2 M :- $is_name X, val X V _, !, unif {hd-beta V C1} T C2 M. % we could use VN if nonflex

% flip
unif X C1 Y C2 ff :- !, unif Y C2 X C1 tt.

% error
% unif X C1 Y C2 _tt :- !,
%   $print "Error: " {pp {zip X C1}} "vs" {pp {zip Y C2}}. %, halt.

% Contexts happens to be lists, so we just reuse the code
unify-list L1 L2 :- unify-ctxs L1 L2.

% the entry points: unify unify-ctxs
mode (unify-ctxs i i).
unify-ctxs [] [].
unify-ctxs [X|XS] [Y|YS] :- unify X Y, unify-ctxs XS YS.

unify A B :- unif {hd-beta A []} {hd-beta B []} ff.

% Binding a list of terms (delift in Matita, invert subst in Coq) %%%%%%%%%%%%%

% We use a keyd discipline, i.e. we only bind terms with a rigid head
macro @key C :- (C = const _ ; C = indt _ ; C = indc _ ; $is_name C).

type bind-list list term -> term -> A -> prop.
mode (bind-list i i o).
bind-list [] T T' :- (copy T T').
bind-list [ ?? |VS] T R :- !, pi x\ bind-list VS T (R x).
bind-list [app [C| AS] |VS] T R :- @key C, !,
  pi x\ (pi L\ copy (app[C|L]) x :- unify-list L AS) => bind-list VS T (R x).
bind-list [C|VS] T R :- @key C, !,
  pi x\ copy C x => bind-list VS T (R x).

type copy term -> term -> prop.
mode (copy i o).
% @log (copy _ _).
copy X Y :- $is_name X, X = Y, !.
copy X Y :- $is_name X, val X T _, !, copy T Y.
copy (const _ as C) C :- !.
copy (indc _ as C) C :- !.
copy (indt _ as C) C :- !.
copy (sort _ as C) C :- !.
copy (fix N Rno Ty F) (fix N Rno Ty1 F1) :- !,
  copy Ty Ty1, pi x\ @pp x N => copy (F x) (F1 x).
copy (match T Rty B) (match T1 Rty1 B1) :- !,
  copy T T1, copy Rty Rty1, map B copy B1.
copy (app L) (app L1) :- !, map L copy L1.
copy (lam N T F) (lam N T1 F1) :- !,
  copy T T1, pi x\ @pp x N => copy (F x) (F1 x).
copy (let N T B F) (let N T1 B1 F1) :- !,
  copy T T1, copy B B1, pi x\ @pp x N => copy (F x) (F1 x).
copy (prod N T F) (prod N T1 F1) :- !,
  copy T T1, pi x\ @pp x N => copy (F x) (F1 x).
copy (?? M L) W :- map L copy L1, mk-app M L1 W.

%%%%% eat-prod head head-ty args-done todo-args refined-app refined-ty %%%%%%%%

mode (eat-prod i i i o o o).
%@log (eat-prod _ _ _ _ _ _).

eat-prod [] Hd Prod Adone Res ResTy :- !,
  unify Res {mk-app Hd {rev Adone}}, unify ResTy Prod.

% XXX why not unif?
eat-prod [A|AS] Hd Prod Adone Res ResTy :-
  if (whd Prod [] (prod _ Src Tgt) [])
    (of A Src ResA, eat-prod AS Hd (Tgt ResA) [ResA|Adone] Res ResTy)
    fail. %(fail-with "not a prod").

type of term -> term -> term -> prop.
mode (of i o o).
%@log (of _ _ _).

macro @of X N T :- ((pi Tx\ of X Tx X :- !, unify T Tx),pp X N :- !).

of (lam N S F) LamTy (lam N S2 F2) :-
  of (prod N S _T) (sort _U) (prod M S2 T),
  unify LamTy (prod M S2 T),
  pi x\ @of x N S2 => of (F x) (T x) (F2 x).

of (app [Hd|Args]) TyApp App :-
  of Hd Prod Hd1, eat-prod Args Hd1 Prod [] App TyApp.

of (prod N S F) ProdTy (prod N ResS ResF) :-
  of S (sort U1) ResS,
  (pi x\ @of x N ResS => of (F x) (sort U2) (ResF x)),
  %pts U1 U2 U,
  unify ProdTy (sort U).

of (match T Rty Bs) ResRtyInst (match ResT ResRty ResBs) :-
  of T TyT ResT,
  % T : TyT = (indt GR) LArgs RArgs, and (indt GR) : Ty
  safe-dest-app TyT (indt GR) Args,
  coq-env-indt GR _IsInd Lno _Luno Ty Kn Ks, % TODO LUno
  split-at Lno Args LArgs RArgs, % TODO: not a failure, just type err
  % fix LArgs on ind ty and constructors ty
  subst-prod LArgs Ty TyLArgs,
  map Ks (subst-prod LArgs) KsLArgs,
  % Rty skeleton (uknown ending) = lam rargs, lam e : indt largs rargs, ?
  mk-rty [] {mk-app (indt GR) LArgs} TyLArgs ResRtyRaw, 
  of ResRtyRaw _ ResRty, unify Rty ResRty,
  % Rty must type each branch
  map2 KsLArgs Kn (mk-bty Rty Lno) BsTy,
  map2 Bs BsTy of ResBs,
  % Outside type
  unify {mk-app ResRty {append RArgs [ResT]}} ResRtyInst.

of (let N Ty Bo F) TyFx (let N ResTy ResBo ResF) :-
  of Ty (sort _) ResTy, of Bo ResTy ResBo, of _ ResTy ResBoNorm,
  pi x\ @of x N ResTy => val x ResBo ResBoNorm => of (F x) TyFx (ResF x).

of (fix N Rno Ty BoF) ResTy (fix N Rno RTy ResBoF) :-
  of Ty (sort _) RTy,
  unify ResTy RTy,
  pi f\ @of f N RTy => of (BoF f) ResTy (ResBoF f).
 
of (sort prop) (sort (typ _)) (sort prop).
of (sort (typ T)) (sort (typ T+1)) (sort (typ T)) :- coq-univ-ltn T T+1.
of (indt GR as X) T X :- !, coq-env-indt GR _ _ _ T1 _ _, unify T T1.
of (indc GR as X) T X :- !, coq-env-indc GR _ _ T1, unify T T1.
of (const GR as X) T X :- !, coq-env-const GR _ T1, unify T T1.

of (?? as X) T Y :- !, Y = X, $constraint (of X T X) [X].

constraint of val {
 %rule (G ?- of X T Y) <=> ($print (G ?- of X T Y)).
}

of hole TY X :- of _FRESH TY X.

% typing match %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type mk-rty list term -> term -> term -> term -> prop. 
mk-rty ARGS HD (prod N S T) (lam N S F) :- !,
  pi x\ mk-rty [x|ARGS] HD (T x) (F x).
mk-rty ARGS HD _ (lam _ IndApp _FRESH) :-
  mk-app HD {rev ARGS} IndApp.

type mk-bty term -> int -> term -> term -> term -> prop.
mk-bty Rty Lno (prod N S T) Ki (prod N S B) :- !,
  pi x\ mk-bty Rty Lno (T x) Ki (B x).
mk-bty Rty Lno T Ki AppRtyNorm :-
  safe-dest-app T (indt _) Args,
  split-at Lno Args LArgs RArgs,
  mk-app Rty {append RArgs [{mk-app Ki {append LArgs RArgs}}]} AppRty,
  hd-beta-zeta-reduce AppRty AppRtyNorm.

% PTS sorts %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pts prop prop prop.
pts (typ _) prop prop.
pts (typ T1) (typ T2) (typ M) :- coq-univ-leq T1 T2 M.

coq-univ-leq _ _ _. % TODO
coq-univ-ltn _ _. % TODO

% vim:set ft=lprolog spelllang=:
